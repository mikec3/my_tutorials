{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\"use strict\";\n\nvar errors = require('web3-core-helpers').errors;\n\nvar EventEmitter = require('eventemitter3');\n\nvar formatters = require('web3-core-helpers').formatters;\n\nfunction identity(value) {\n  return value;\n}\n\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = identity;\n  this.arguments = null;\n  this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n} // INHERIT\n\n\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nSubscription.prototype._validateArgs = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) subscription = {};\n  if (!subscription.params) subscription.params = 0;\n\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nSubscription.prototype._formatInput = function (args) {\n  var subscription = this.options.subscription;\n\n  if (!subscription) {\n    return args;\n  }\n\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n\n  var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\n\n\nSubscription.prototype._formatOutput = function (result) {\n  var subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n\nSubscription.prototype._toPayload = function (args) {\n  var params = [];\n  this.callback = this._extractCallback(args) || identity;\n\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift(); // replace subscription with given name\n\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n\n    this._validateArgs(this.arguments);\n\n    args = []; // make empty after validation\n  } // re-add subscriptionName\n\n\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n\n  return {\n    method: this.options.type + '_subscribe',\n    params: params\n  };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\n\n\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.lastBlock = null;\n  this.removeAllListeners();\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\n\n\nSubscription.prototype.subscribe = function () {\n  var _this = this;\n\n  var args = Array.prototype.slice.call(arguments);\n\n  var payload = this._toPayload(args);\n\n  if (!payload) {\n    return this;\n  } // throw error, if provider is not set\n\n\n  if (!this.options.requestManager.provider) {\n    setTimeout(function () {\n      var err1 = new Error('No provider set.');\n\n      _this.callback(err1, null, _this);\n\n      _this.emit('error', err1);\n    }, 0);\n    return this;\n  } // throw error, if provider doesnt support subscriptions\n\n\n  if (!this.options.requestManager.provider.on) {\n    setTimeout(function () {\n      var err2 = new Error('The current provider doesn\\'t support subscriptions: ' + _this.options.requestManager.provider.constructor.name);\n\n      _this.callback(err2, null, _this);\n\n      _this.emit('error', err2);\n    }, 0);\n    return this;\n  } // Re-subscription only: continue fetching from the last block we received.\n  // a dropped connection may have resulted in gaps in the logs...\n\n\n  if (this.lastBlock && !!this.options.params && typeof this.options.params === 'object') {\n    payload.params[1] = this.options.params;\n    payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n  } // if id is there unsubscribe first\n\n\n  if (this.id) {\n    this.unsubscribe();\n  } // store the params in the options object\n\n\n  this.options.params = payload.params[1]; // get past logs, if fromBlock is available\n\n  if (payload.params[0] === 'logs' && !!payload.params[1] && typeof payload.params[1] === 'object' && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n    // copy the params to avoid race-condition with deletion below this block\n    var blockParams = Object.assign({}, payload.params[1]);\n    this.options.requestManager.send({\n      method: 'eth_getLogs',\n      params: [blockParams]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          var output = _this._formatOutput(log);\n\n          _this.callback(null, output, _this);\n\n          _this.emit('data', output);\n        }); // TODO subscribe here? after the past logs?\n      } else {\n        setTimeout(function () {\n          _this.callback(err, null, _this);\n\n          _this.emit('error', err);\n        }, 0);\n      }\n    });\n  } // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n\n  if (typeof payload.params[1] === 'object') delete payload.params[1].fromBlock;\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n      _this.method = payload.params[0];\n\n      _this.emit('connected', result); // call callback on notifications\n\n\n      _this.options.requestManager.addSubscription(_this, function (error, result) {\n        if (!error) {\n          if (!Array.isArray(result)) {\n            result = [result];\n          }\n\n          result.forEach(function (resultItem) {\n            var output = _this._formatOutput(resultItem); // Track current block (for gaps introduced by dropped connections)\n\n\n            _this.lastBlock = !!output && typeof output === 'object' ? output.blockNumber : null;\n\n            if (typeof _this.options.subscription.subscriptionHandler === 'function') {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            } else {\n              _this.emit('data', output);\n            } // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n            _this.callback(null, output, _this);\n          });\n        } else {\n          _this.callback(error, false, _this);\n\n          _this.emit('error', error);\n        }\n      });\n    } else {\n      setTimeout(function () {\n        _this.callback(err, false, _this);\n\n        _this.emit('error', err);\n      }, 0);\n    }\n  }); // return an object to cancel the subscription\n\n  return this;\n};\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\n\n\nSubscription.prototype.resubscribe = function () {\n  this.options.requestManager.removeSubscription(this.id); // unsubscribe\n\n  this.id = null;\n  this.subscribe(this.callback);\n};\n\nmodule.exports = Subscription;","map":{"version":3,"sources":["/Users/michaelcouch/Documents/Ethereum/My_Tutorials/react_metaMask_connection/metamask_conn/node_modules/web3-core-subscriptions/lib/subscription.js"],"names":["errors","require","EventEmitter","formatters","identity","value","Subscription","options","call","id","callback","arguments","lastBlock","subscription","type","requestManager","prototype","Object","create","constructor","_extractCallback","args","length","pop","_validateArgs","params","InvalidNumberOfParams","subscriptionName","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","subscribe","_this","Array","slice","payload","provider","setTimeout","err1","emit","on","err2","name","fromBlock","inputBlockNumberFormatter","hasOwnProperty","isFinite","blockParams","assign","send","err","logs","forEach","log","output","addSubscription","error","isArray","resultItem","blockNumber","subscriptionHandler","resubscribe","module","exports"],"mappings":"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","sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\"use strict\";\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\nvar formatters = require('web3-core-helpers').formatters;\nfunction identity(value) {\n    return value;\n}\nfunction Subscription(options) {\n    EventEmitter.call(this);\n    this.id = null;\n    this.callback = identity;\n    this.arguments = null;\n    this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager\n    };\n}\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nSubscription.prototype._extractCallback = function (args) {\n    if (typeof args[args.length - 1] === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nSubscription.prototype._validateArgs = function (args) {\n    var subscription = this.options.subscription;\n    if (!subscription)\n        subscription = {};\n    if (!subscription.params)\n        subscription.params = 0;\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nSubscription.prototype._formatInput = function (args) {\n    var subscription = this.options.subscription;\n    if (!subscription) {\n        return args;\n    }\n    if (!subscription.inputFormatter) {\n        return args;\n    }\n    var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n        return formatter ? formatter(args[index]) : args[index];\n    });\n    return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\nSubscription.prototype._formatOutput = function (result) {\n    var subscription = this.options.subscription;\n    return (subscription && subscription.outputFormatter && result) ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n    var params = [];\n    this.callback = this._extractCallback(args) || identity;\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift();\n        // replace subscription with given name\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName;\n        }\n    }\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args);\n        this._validateArgs(this.arguments);\n        args = []; // make empty after validation\n    }\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod);\n    params = params.concat(this.arguments);\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n    }\n    return {\n        method: this.options.type + '_subscribe',\n        params: params\n    };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function (callback) {\n    this.options.requestManager.removeSubscription(this.id, callback);\n    this.id = null;\n    this.lastBlock = null;\n    this.removeAllListeners();\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function () {\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments);\n    var payload = this._toPayload(args);\n    if (!payload) {\n        return this;\n    }\n    // throw error, if provider is not set\n    if (!this.options.requestManager.provider) {\n        setTimeout(function () {\n            var err1 = new Error('No provider set.');\n            _this.callback(err1, null, _this);\n            _this.emit('error', err1);\n        }, 0);\n        return this;\n    }\n    // throw error, if provider doesnt support subscriptions\n    if (!this.options.requestManager.provider.on) {\n        setTimeout(function () {\n            var err2 = new Error('The current provider doesn\\'t support subscriptions: ' +\n                _this.options.requestManager.provider.constructor.name);\n            _this.callback(err2, null, _this);\n            _this.emit('error', err2);\n        }, 0);\n        return this;\n    }\n    // Re-subscription only: continue fetching from the last block we received.\n    // a dropped connection may have resulted in gaps in the logs...\n    if (this.lastBlock && !!this.options.params && typeof this.options.params === 'object') {\n        payload.params[1] = this.options.params;\n        payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n    }\n    // if id is there unsubscribe first\n    if (this.id) {\n        this.unsubscribe();\n    }\n    // store the params in the options object\n    this.options.params = payload.params[1];\n    // get past logs, if fromBlock is available\n    if (payload.params[0] === 'logs' && !!payload.params[1] && typeof payload.params[1] === 'object' && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n        // send the subscription request\n        // copy the params to avoid race-condition with deletion below this block\n        var blockParams = Object.assign({}, payload.params[1]);\n        this.options.requestManager.send({\n            method: 'eth_getLogs',\n            params: [blockParams]\n        }, function (err, logs) {\n            if (!err) {\n                logs.forEach(function (log) {\n                    var output = _this._formatOutput(log);\n                    _this.callback(null, output, _this);\n                    _this.emit('data', output);\n                });\n                // TODO subscribe here? after the past logs?\n            }\n            else {\n                setTimeout(function () {\n                    _this.callback(err, null, _this);\n                    _this.emit('error', err);\n                }, 0);\n            }\n        });\n    }\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n    if (typeof payload.params[1] === 'object')\n        delete payload.params[1].fromBlock;\n    this.options.requestManager.send(payload, function (err, result) {\n        if (!err && result) {\n            _this.id = result;\n            _this.method = payload.params[0];\n            _this.emit('connected', result);\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this, function (error, result) {\n                if (!error) {\n                    if (!Array.isArray(result)) {\n                        result = [result];\n                    }\n                    result.forEach(function (resultItem) {\n                        var output = _this._formatOutput(resultItem);\n                        // Track current block (for gaps introduced by dropped connections)\n                        _this.lastBlock = !!output && typeof output === 'object' ? output.blockNumber : null;\n                        if (typeof _this.options.subscription.subscriptionHandler === 'function') {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output);\n                        }\n                        else {\n                            _this.emit('data', output);\n                        }\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        _this.callback(null, output, _this);\n                    });\n                }\n                else {\n                    _this.callback(error, false, _this);\n                    _this.emit('error', error);\n                }\n            });\n        }\n        else {\n            setTimeout(function () {\n                _this.callback(err, false, _this);\n                _this.emit('error', err);\n            }, 0);\n        }\n    });\n    // return an object to cancel the subscription\n    return this;\n};\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\nSubscription.prototype.resubscribe = function () {\n    this.options.requestManager.removeSubscription(this.id); // unsubscribe\n    this.id = null;\n    this.subscribe(this.callback);\n};\nmodule.exports = Subscription;\n"]},"metadata":{},"sourceType":"script"}